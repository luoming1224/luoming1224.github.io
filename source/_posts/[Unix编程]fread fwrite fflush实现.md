---
title: '[Unix编程]fread/fwrite/fflush实现'
date: 2018-11-30 14:55:30
categories: 'Unix编程'
tags: [fread, fwrite, fflush, fsync]
---
由于redis中涉及到fread、fwrite、fflush、fsync这四个命令的使用，所以做一个总结笔记，方便查阅。

<!--more-->

# fread/read fwrite/write实现与区别

fread就是通过read来实现的，fread是C语言的库，而read是系统调用。

差别在read每次读的数据是调用者要求的大小，比如调用者要求读取10个字节数据，read就会从内核缓冲区（操作系统开辟的一段空间用来存储磁盘上的数据）读10个字节数据到数组中，所以每次调用read会涉及到用户态与內核态之间的切换从而损耗一定的性能。而fread不一样，为了加快读的速度，fread每次都会从内核缓冲区读比要求更多的数据，然后放到应用进程缓冲区(首地址存在FILE结构体中)，这样下次再读数据只需要到应用进程缓冲区中去取而无需过多的系统调用。

fwrite也是通过write来实现的，fwrite是C语言的库，而write是系统调用。

差别在write每次写的数据是调用者要求的大小，比如调用者要求写入10个字节数据，write就会写10个字节数据到内核缓冲区中，所以依然涉及到用户态与內核态之间的切换，操作系统会定期地把这些存在内核缓冲区的数据写回磁盘中。而fwrite不一样，fwrite每次都会先把数据写入一个应用进程缓冲区，等到该缓冲区满了，或者调用类似调用fflush这种冲洗缓冲区的函数时，系统会调用write一次性把相应数据写进内核缓冲区中。同样减少了系统调用(即write调用)。

所以我们应该知道，实际上write和read不会直接从磁盘文件中读写数据。例如read是从磁盘所关联的一个内核缓冲区读写数据。(因为磁盘读取数据速度实在太慢了，所以操作系统往往采用预读技术读取磁盘数据)。write也是仅将数据写进内核缓冲区，操作系统通过运行一个守护进程，定期的将内核缓冲区写入磁盘。

# fflush、fsync实现与区别
## 延迟写
延迟写（delayed write）: 传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则 并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。

延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

## sync函数
sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。

通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。

## fsync函数
fsync将内核缓冲区中的内容真正写入磁盘，fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。并且fsync除了写入数据外，还会将文件的元信息同步更新到文件。

fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。

## fdatasync函数
fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。

对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。

## fflush
标准IO函数（如fread，fwrite等）会在内存中建立缓冲，**该函数刷新内存缓冲，将内容写入内核缓冲**，要想将其真正写入磁盘，还需要调用fsync。（即先调用fflush然后再调用fsync，否则不会起作用）。fflush以指定的文件流描述符为参数（对应以fopen等函数打开的文件流），仅仅是把上层缓冲区中的数据刷新到内核缓冲区就返回，

因此相对于fsync而言不是很安全，还需要再调用一下fsync来把数据真正写入硬盘。使用函数

> int fileno(FILE *stream);

把文件流描述符（fp）转换为文件描述符（fd），以方便fsync的调用，那么，在Linux操作系统上，怎样才能保证数据被正确地写入外部永久存储介质？

* write不能满足要求，需要fsync

对于write函数，我们认为该函数一旦返回，数据便已经写到了文件中。但是这种概念只是宏观上的，一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内核缓冲区，而内核缓冲区中数据不会立即更新到硬盘中，而是由操作系统统一调度，如flusher内核线程在满足一定条件时（一定时间间隔、内存中的脏页达到一定比例）将内核缓冲区中数据同步到硬盘上（放入设备的IO请求队列）。因为write调用不会等到硬盘IO完成之后才返回，设想如果操作系统在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要操作系统提供的同步IO（synchronized-IO）原语来保证：

函数原型：
	
> int fsync(int fd); 
	
fsync的功能是确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。

* fsync与fdatasync区别

除了同步文件的修改内容（脏页），fsync还会同步文件的描述信息（metadata，包括size、访问时间等等），因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作，多余的一次IO操作，根据Wikipedia的数据，当前硬盘驱动的平均寻道时间（Average seek time）大约是3~15ms，7200RPM硬盘的平均旋转延迟（Average rotational latency）大约为4ms，因此一次IO操作的耗时大约为10ms左右。Posix同样定义了fdatasync，放宽了同步的语义以提高性能：
	
> int fdatasync(int fd);
	
fdatasync的功能与fsync类似，但是仅仅在必要的情况下才会同步，因此可以减少一次IO写操作。

# 内核缓冲区、应用缓冲区
应用缓冲技术能很明显的提高系统效率。内核与外围设备的数据交换，内核与用户空间的数据交换都是比较费时的，使用缓冲区就是为了优化这些费时的操作。其实核心到用户空间的操作本身是不buffer的，是由I/O库用buffer来优化了这个操作。比如read本来从内核读取数据时是比较费时的，所以一次取出一块，以避免多次陷入内核。

应用内核缓冲区的 主要思想就是一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。

管理员模式和用户模式之间的切换需要消耗时间，但相比之下，磁盘的I/O操作消耗的时间更多，为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度。磁盘是数据块 的集合，内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而 是将内核缓冲区中的数据复制到进程的缓冲区中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起，接着为其 他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程。

注：理解内核缓冲区技术的原理有助于更好的掌握系统调用read&write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。

从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一 次写入。有时会导致意外情况，比如断电，内核还来不及把内核缓冲区中的数据写道磁盘上，这些更新的数据就会丢失。

应用内核缓冲技术导致的结果是：提高了磁盘的I/O效率；优化了磁盘的写操作；需要及时的将缓冲数据写到磁盘。

同时我们也加深了对read/write是阻塞命令的理解，在网络I/O操作中，我们也说到read是从内核缓冲区中读入数据到应用缓冲区中，而且如果数据还没有收到，内核缓冲区为空，则read会一直阻塞等待，直到数据到达内核缓冲区。

#总结
* fread从应用进程的应用缓冲区中读取数据
* fwrite将数据写入应用进程的应用缓冲区
* read从内核缓冲区中读入数据到应用缓冲区
* write将数据从应用缓冲区写入内核缓冲区
* fflush将数据从应用缓冲区冲刷到内核缓冲区
* fsync将内核缓冲区中的数据真正同步到磁盘文件

所以可以看出fflush和fsync的调用顺序应该是：
fwrite -----> c库缓冲-----> fflush---------〉内核缓冲--------fsync-----〉磁盘

read/write/fsync： 

1. linux底层操作；

2. 内核调用， 涉及到进程上下文的切换，即用户态到核心态的转换，这是个比较消耗性能的操作。

fread/fwrite/fflush： 

1. c语言标准规定的io流操作，建立在read/write/fsync之上

2. 在用户层， 又增加了一层缓冲机制，用于减少内核调用次数，但是增加了一次内存拷贝。

两者之间的关系，见下图：
![](https://i.imgur.com/Kfisi03.png)



# 参考资料
* [函数sync、fsync与fdatasync的总结整理(必看篇)](https://www.jb51.net/article/101062.htm)
* [read/fread write/fwrite 的实现原理](https://blog.csdn.net/xiaofei0859/article/details/74686254)
* [关于内核缓冲区，和应用程序缓冲区](https://blog.csdn.net/yy660560/article/details/69525721)
* [fflush和fsync的一些总结](https://blog.csdn.net/abcd1f2/article/details/53436244)
* [read/write/fsync与fread/fwrite/fflush的关系和区别](https://blog.csdn.net/ybxuwei/article/details/22727565)